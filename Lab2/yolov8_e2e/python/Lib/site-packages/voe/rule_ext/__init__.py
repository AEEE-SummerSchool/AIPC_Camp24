##
##  © Copyright 2022 – 2023 Advanced Micro Devices, Inc. All rights reserved.
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##  http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
"""
a rule definition.

a rule contains a pattern, an action and optionally where clause.

When applying a rule, we search nodes for the `pattern`, if matched and
`where` clause returns true then the `action` is taken.


"""

import abc

from .builder import Builder
from .imp.node_builder_proxy import NodeBuilderProxy

# re-export  same_as
# pylint: disable=unused-import
# flake8: noqa
from .imp.util import same_as
from .node import Node


class Rule(metaclass=abc.ABCMeta):
    """a virtual base class for define a rule.

    Every rule need to derived from this class and implement `action`
    and `pattern`."""

    def __init__(self):
        self._graph = None
        self._pass = None
        self._binder = None

    def initialize(self, graph, vaip_pass, binder):
        """this funciton is called by c++ to intialize binder"""
        self._graph = graph
        self._pass = vaip_pass
        self._binder = binder

    @abc.abstractmethod
    def pattern(self):
        """the pattern() is searched for"""

    @abc.abstractmethod
    def action(self, **kwargs):
        """the action is taken when the pattern() is matched"""

    def where(self, **_kwargs):
        """the optional where clause"""
        return True

    def _where(self, **kwargs):
        """this funciton is called by c++ code, and convert c++ NodeInput object to Node"""
        return self.where(
            **{k: Node(self._pass, self._graph, v) for (k, v) in kwargs.items()}
        )

    def _action(self, **kwargs):
        """this funciton is called by c++ code, and convert c++ NodeInput object to Node"""
        return self.action(
            **{
                k: Node(self._pass, self._graph, v)
                for (k, v) in kwargs.items()
                if not v.empty()
            }
        )

    def get_node(self, node_name: str) -> Node:
        """return the matched node"""
        assert isinstance(node_name, str)
        return Node(self._pass, self._graph, self._binder[node_name])

    # pylint: disable=too-many-arguments
    def create_node(
        self,
        op_type=None,
        inputs=None,
        attrs=None,
        data_type=None,
        shape=None,
        anchor_point=None,
    ):
        """create a a new node"""
        if inputs is None:
            inputs = []
        if attrs is None:
            attrs = {}
        builder = Builder(self._graph.builder(self._pass))

        ## builder will ready to build after NodeBuilderProxy.build()
        NodeBuilderProxy(
            self, builder, op_type, inputs, attrs, data_type, shape, anchor_point
        ).build()
        return builder.build(self._pass, self._graph)

    def try_fuse(self, pattern, inputs, outputs, constant_initializers1, device):
        inputs = [input.as_cpp_node_input() for input in inputs]
        outputs = [output.as_cpp_node_input() for output in outputs]
        return self._pass.try_fuse(
            self._graph,
            pattern.as_cpp_node_input(),
            inputs,
            outputs,
            constant_initializers1,
            device,
        )

    def fuse(self, meta_def):
        return self._pass.fuse(self._graph, meta_def)

    def cache_dir(self):
        return self._pass.get_cache_dir_with_key()


def is_rule(obj):
    """whether the object is a Rule"""
    return isinstance(obj, Rule)
