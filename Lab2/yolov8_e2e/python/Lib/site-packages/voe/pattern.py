##
##  © Copyright 2022 – 2023 Advanced Micro Devices, Inc. All rights reserved.
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##  http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
import json


class _PatternTag(str):
    pass


class Pattern(dict):
    def __init__(self, **kargs):
        super().__init__(**kargs)

    def build(self, env):
        patterns = self._build(env, [])
        self["is_root"] = True
        return _PatternTag(json.dumps({"patterns": patterns}, sort_keys=True, indent=4))

    def _build(self, env, patterns):
        ## prevent a pattern from building itself more than once.
        for p in patterns:
            if p is self:
                return patterns

        if "call_node" in self:
            self._build_node(env, patterns)
        elif "wildcard" in self:
            self._build_wildcard(env, patterns)
        elif "graph_input" in self:
            self._build_graph_input(env, patterns)
        else:
            assert "not a valid pattern"

        ## put it into the enviroment if this is a named pattern or it
        ## is the root pattern.
        if "is_root" in self or "id" in self:
            patterns.extend([self])

        return patterns

    def _build_node(self, env, patterns):
        self["call_node"]["args"] = self._build_node_args(
            self["call_node"]["args"], env, patterns
        )
        if "optional_args" in self["call_node"]:
            self["call_node"]["optional_args"] = self._build_node_args(
                self["call_node"]["optional_args"], env, patterns
            )
        self._set_id(env)

    def _build_node_args(self, args, env, patterns):
        for arg in args:
            arg["pattern"]._build(env, patterns)
        return [
            {"name": arg["pattern"]["id"]} if "id" in arg["pattern"] else arg
            for arg in args
        ]

    def _build_wildcard(self, env, patterns):
        self._set_id(env)

    def _build_graph_input(self, env, patterns):
        self._set_id(env)

    def _set_id(self, env):
        for k, v in env.items():
            if v is self:
                v["id"] = k


def wildcard():
    ret = Pattern(wildcard={})
    return ret


def graph_input():
    ret = Pattern(graph_input={})
    return ret


def node(op_type, *args):
    ret = Pattern(
        call_node={
            "op_type": op_type,
            "args": [{"pattern": arg} for arg in args if not isinstance(arg, list)],
            "optional_args": [
                {"pattern": arg[0]} for arg in args if isinstance(arg, list)
            ],
        }
    )
    return ret


def xir_const_op():
    return node("com.xilinx:const")


def is_pattern(obj):
    return isinstance(obj, _PatternTag)
