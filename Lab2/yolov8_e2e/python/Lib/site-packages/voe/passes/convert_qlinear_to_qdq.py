##
##  © Copyright 2022 – 2023 Advanced Micro Devices, Inc. All rights reserved.
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##  http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##

from voe.anchor_point import CONST, FIX2FLOAT, FLOAT2FIX, scale_to_fixpoint
from voe.pattern import node, wildcard
from voe.rule_ext import Rule, same_as


class QLinearRule(Rule):
    def DequantizeLinear(self, x, x_scale, x_zero_point, anchor_point):
        return self.create_node(
            op_type="ai.onnx:DequantizeLinear",
            inputs=[x, x_scale, x_zero_point],
            data_type="float32",
            shape=same_as(x),
            anchor_point=anchor_point,
        )

    def DequantizeLinear_2(self, x, x_scale, x_zero_point):
        AP2 = FIX2FLOAT(scale_to_fixpoint(x_scale.const_data()[0]))
        return self.create_node(
            op_type="ai.onnx:DequantizeLinear",
            inputs=[x, x_scale, x_zero_point],
            data_type="float32",
            shape=same_as(x),
            anchor_point=(x, AP2),
        )

    def QuantizeLinear(self, x, x_scale, x_zero_point, anchor_point):
        return self.create_node(
            op_type="ai.onnx:QuantizeLinear",
            inputs=[x, x_scale, x_zero_point],
            data_type=same_as(x_zero_point),
            shape=same_as(x),
            anchor_point=anchor_point,
        )

    def QuantizeLinear_2(self, x, x_scale, x_zero_point):
        AP2 = FLOAT2FIX(scale_to_fixpoint(x_scale.const_data()[0]))
        return self.create_node(
            op_type="ai.onnx:QuantizeLinear",
            inputs=[x, x_scale, x_zero_point],
            data_type=same_as(x_zero_point),
            shape=same_as(x),
            anchor_point=(x, AP2),
        )

    def const(self, data_type, shape, anchor_point):
        return self.create_node(
            op_type="com.xilinx:const",
            data_type=data_type,
            shape=same_as(shape),
            anchor_point=(anchor_point, CONST),
        )


def check(scale):
    n = 0
    num = scale.const_data()[0]
    while True:
        value = pow(0.5, n)
        if num == value:
            return True
        elif num > value:
            return False
        n += 1


class ConvertQLinearConv(QLinearRule):
    """
    test case model q_operator_resnet50
    From : QLinearConv(x, x_scale, x_zero_point, w, w_scale, w_zero_point, y_scale, y_zero_point, [B])
    To  : QuantizeLinear(Conv(DeQuantizeLinear(x, x_scale, x_zero_point), DeQuantizeLinear(w, w_scale, w_zero_point), DeQuantizeLinear(x, x_scale*w_scale, x_zero_point)), y_scale, y_zero_point)
    """

    def pattern(self):
        x = wildcard()
        x_scale = wildcard()
        x_zero_point = wildcard()
        w = wildcard()
        w_scale = wildcard()
        w_zero_point = wildcard()
        y_scale = wildcard()
        y_zero_point = wildcard()
        B = wildcard()
        qlinearconv = node(
            "QLinearConv",
            x,
            x_scale,
            x_zero_point,
            w,
            w_scale,
            w_zero_point,
            y_scale,
            y_zero_point,
            [B],
        )
        return qlinearconv.build(locals())

    def where(self, x_scale, w_scale, y_scale, x_zero_point, **_kwargs):
        if check(x_scale) and check(w_scale) and check(y_scale):
            return x_zero_point.const_data()[0] == 0
        return False

    def action(
        self,
        x,
        x_scale,
        x_zero_point,
        w,
        w_scale,
        w_zero_point,
        y_scale,
        y_zero_point,
        qlinearconv,
        **_others
    ):
        conv_x = self.DequantizeLinear_2(x, x_scale, x_zero_point)
        conv_w = self.DequantizeLinear_2(w, w_scale, w_zero_point)
        if "B" in _others:
            B = _others["B"]
            B_scale = self.const("float32", x_scale, qlinearconv)
            B_scale.create_const(
                [x * y for x, y in zip(x_scale.const_data(), w_scale.const_data())]
            )
            B_zero_point = self.const(same_as(B), x_zero_point, qlinearconv)
            B_zero_point.create_const(x_zero_point.const_data())

            conv_b = self.DequantizeLinear_2(B, B_scale, B_zero_point)
            conv_inputs = [conv_x, conv_w, conv_b]
        else:
            conv_inputs = [conv_x, conv_w]

        conv = self.create_node(
            op_type="ai.onnx:Conv",
            inputs=conv_inputs,
            data_type="float32",
            shape=same_as(qlinearconv),
            attrs=same_as(qlinearconv),
            anchor_point=(qlinearconv, CONST),
        )
        return self.QuantizeLinear(conv, y_scale, y_zero_point, qlinearconv)


class ConvertQLinearAdd(QLinearRule):
    """
    test case model q_operator_resnet50
    From : QLinearAdd(x, x_scale, x_zero_point, y, y_scale, y_zero_point, c_scale, c_zero_point)
    To  : QuantizeLinear(Add(DeQuantizeLinear(x, x_scale, x_zero_point), DeQuantizeLinear(y, y_scale, y_zero_point)), c_scale, c_zero_point)
    """

    def pattern(self):
        x = wildcard()
        x_scale = wildcard()
        x_zero_point = wildcard()
        y = wildcard()
        y_scale = wildcard()
        y_zero_point = wildcard()
        c_scale = wildcard()
        c_zero_point = wildcard()
        qlinearadd = node(
            "com.microsoft:QLinearAdd",
            x,
            x_scale,
            x_zero_point,
            y,
            y_scale,
            y_zero_point,
            c_scale,
            c_zero_point,
        )
        return qlinearadd.build(locals())

    def where(self, x_scale, c_scale, y_scale, **_kwargs):
        return check(x_scale) and check(c_scale) and check(y_scale)

    def action(
        self,
        x,
        x_scale,
        x_zero_point,
        y,
        y_scale,
        y_zero_point,
        c_scale,
        c_zero_point,
        qlinearadd,
        **_others
    ):
        add_x = self.DequantizeLinear_2(x, x_scale, x_zero_point)
        add_y = self.DequantizeLinear_2(y, y_scale, y_zero_point)

        add_c = self.create_node(
            op_type="ai.onnx:Add",
            inputs=[add_x, add_y],
            data_type="float32",
            shape=same_as(qlinearadd),
            attrs=same_as(qlinearadd),
            anchor_point=(qlinearadd, CONST),
        )
        return self.QuantizeLinear(add_c, c_scale, c_zero_point, qlinearadd)


class ConvertQLinearGlobalAveragePool(QLinearRule):
    """
    test case model q_operator_resnet50
    From : QLinearGlobalAveragePool(input, x_scale, x_zero_point, y_scale, y_zero_point)
    To  : QuantizeLinear(GlobalAveragePool(DeQuantizeLinear(input, x_scale, x_zero_point)), y_scale, y_zero_point)
    """

    def pattern(self):
        x = wildcard()
        x_scale = wildcard()
        x_zero_point = wildcard()
        y_scale = wildcard()
        y_zero_point = wildcard()
        y_node = node(
            "com.microsoft:QLinearGlobalAveragePool",
            x,
            x_scale,
            x_zero_point,
            y_scale,
            y_zero_point,
        )
        return y_node.build(locals())

    def where(self, y_node, x_scale, y_scale, **kwargs):
        if y_node.attr("channels_last") == 0:
            return check(x_scale) and check(y_scale)
        return False

    def action(
        self, x, x_scale, x_zero_point, y_scale, y_zero_point, y_node, **_others
    ):
        dq = self.DequantizeLinear_2(x, x_scale, x_zero_point)
        y = self.create_node(
            op_type="ai.onnx:GlobalAveragePool",
            inputs=[dq],
            data_type="float32",
            shape=same_as(y_node),
            anchor_point=(y_node, CONST),
        )
        return self.QuantizeLinear(y, y_scale, y_zero_point, y_node)


class AddQDqBeforeAndAfterMainNode(QLinearRule):
    """
    test case model
    From : MaxPool(QuantizeLinear(x, x_scale, x_zero_point))
    To  : QuantizeLinear(MaxPool(DeQuantizeLinear(QuantizeLinear(x, x_scale, x_zero_point), x_scale, x_zero_point)), x_scale, x_zero_point)
    """

    def pattern(self):
        x = wildcard()
        x_scale = wildcard()
        x_zero_point = wildcard()
        q = node("QuantizeLinear", x, x_scale, x_zero_point)
        main_node = node("MaxPool", q)
        return main_node.build(locals())

    def where(self, x_scale, **_kwargs):
        return check(x_scale)

    def action(self, x_scale, x_zero_point, q, main_node, **_others):
        AP2 = FIX2FLOAT(scale_to_fixpoint(x_scale.const_data()[0]))
        new_dq = self.DequantizeLinear_2(q, x_scale, x_zero_point)
        new_main = self.create_node(
            op_type="MaxPool",
            inputs=[new_dq],
            data_type="float32",
            attrs=same_as(main_node),
            shape=same_as(main_node),
            anchor_point=(main_node, AP2),
        )
        return self.QuantizeLinear(new_main, x_scale, x_zero_point, main_node)


class AddQDqBeforeAndAfterSqueeze(QLinearRule):
    """
    test case model q_operator_resnet50
    From : DeQuantizeLinear(Squeeze(sqx, [sqy]), x_scale, x_zero_point)
    To  : DeQuantizeLinear(QuantizeLinear(Squeeze(DeQuantizeLinear(sqx, x_scale, x_zero_point), [sqy]), x_scale, x_zero_point), x_scale, x_zero_point)
    """

    def pattern(self):
        sqx = wildcard()
        sqy = wildcard()
        x = node("Squeeze", sqx, [sqy])
        x_scale = wildcard()
        x_zero_point = wildcard()
        dq = node("DequantizeLinear", x, x_scale, x_zero_point)
        return dq.build(locals())

    def where(self, x_scale, **_kwargs):
        return check(x_scale)

    def action(self, sqx, x_scale, x_zero_point, dq, x, **_others):
        AP2 = FIX2FLOAT(scale_to_fixpoint(x_scale.const_data()[0]))
        new_dq = self.DequantizeLinear_2(sqx, x_scale, x_zero_point)
        if "sqy" in _others:
            inputs = [new_dq, _others["sqy"]]
        else:
            inputs = [new_dq]
        new_main = self.create_node(
            op_type=same_as(x),
            inputs=inputs,
            data_type="float32",
            attrs=same_as(x),
            shape=same_as(x),
            anchor_point=(x, AP2),
        )
        new_x = self.QuantizeLinear_2(new_main, x_scale, x_zero_point)
        return self.DequantizeLinear(new_x, x_scale, x_zero_point, dq)


def rules():
    return [
        ConvertQLinearConv(),
        ConvertQLinearAdd(),
        ConvertQLinearGlobalAveragePool(),
        AddQDqBeforeAndAfterMainNode(),
        AddQDqBeforeAndAfterSqueeze(),
    ]
